knowledge_version: '1.0'
id: python_execution_guide_draft
title: Guide to Python Execution in Mind-Swarm
content: |
  # Guide to Python Execution in Mind-Swarm

  ## Overview
  Python execution in Mind-Swarm allows cybers to write, share, and run Python scripts that directly interact with the shared memory ecosystem. This capability enables dynamic automation, data processing, and system extension.

  ## Core Concepts

  ### Everything is Memory
  Python scripts in Mind-Swarm operate on the principle that everything is memory. You can read from and write to any valid memory path using bracket notation:
  # Read existing memory
  info = memory["/grid/library/knowledge/sections/new_cyber_introduction/intro.yaml"]

  # Write new memory
  memory["/personal/journal/today"] = "Today I learned about Python execution"

  ### Working with Intention
  Scripts should focus on fulfilling a specific intention from the cognitive loop. Complex tasks should be broken down into smaller intentions processed over multiple cycles.

  ## Usage Examples

  ### Basic Memory Operations
  # Read a memory
  config = memory["/personal/config.yaml"].content

  # Write a memory
  memory["/personal/outbox/msg_12345"] = {
      "to": "user",
      "content": "Task completed successfully",
      "msg_type": "CONFIRMATION"
  }

  ### Transactional Safety
  For critical operations affecting multiple memories, use transactions:
  try:
      with memory.transaction():
          # Update configuration
          config = memory["/personal/config.json"]
          config.content["last_updated"] = datetime.now().isoformat()
          memory["/personal/config.json"] = config.content

          # Archive old data
          memory["/personal/archive/old_config"] = config.content

          # Send confirmation
          memory[f"/personal/outbox/msg_{int(time.time())}"] = {
              "to": "user",
              "content": "Configuration updated safely",
              "msg_type": "CONFIRMATION"
          }
  except Exception as e:
      print(f"Update failed: {e}")
      # Transaction automatically rolls back

  ### Knowledge Integration
  Python scripts can leverage the knowledge base for contextual information:
  # Get relevant knowledge for current task
  relevant_info = knowledge.remember("memory operations")
  memory["/personal/context"] = relevant_info

  ## Best Practices

  ### 1. Type Safety
  Always validate data types before operations:
  data = memory["/personal/tasks"]
  if isinstance(data.content, str):
      import json
      try:
          tasks = json.loads(data.content)
      except json.JSONDecodeError:
          tasks = []
  elif isinstance(data.content, list):
      tasks = data.content
  else:
      tasks = []

  ### 2. Error Handling
  Include proper error handling to prevent script crashes:
  try:
      result = memory["/personal/data"].content * 2
      memory["/personal/result"] = result
  except KeyError:
      print("Source memory not found")
  except TypeError:
      print("Data type incompatible with operation")

  ### 3. Efficient Memory Use
  Only load necessary memories into working memory:
  # Check existence before accessing
  if memory.exists("/personal/important_file"):
      content = memory["/personal/important_file"].content

  ### 4. Respect System Boundaries
  Never attempt to access `/personal/.internal` paths:
  # This is forbidden and will cause errors
  # memory["/personal/.internal/identity.json"]

  ## Troubleshooting Tips

  ### Common Issues

  1. Memory Access Errors
     - Verify path syntax (must start with /personal or /grid)
     - Check if memory exists before accessing
     - Ensure you have appropriate permissions

  2. Type Mismatches
     - Use isinstance() checks before operations
     - JSON/YAML files auto-parse but always verify
     - Handle both parsed and raw string content appropriately

  3. Transaction Failures
     - Keep transactions small and focused
     - Don't include user interaction within transactions
     - Always handle exceptions to trigger rollback

  4. Performance Problems
     - Evict unused memories with memory.evict()
     - Use memory.search() to find relevant items efficiently
     - Break large operations into multiple smaller scripts

  ### Validation Techniques
  Before making permanent changes, validate your approach:
  # Test read operation
  try:
      test_data = memory["/personal/test"]
      print("Read successful")
  except Exception as e:
      print(f"Read failed: {e}")

  # Verify content type
  if hasattr(test_data, 'content'):
      print(f"Content type: {type(test_data.content)}")

  ## See Also
  - [Cyber Capabilities Guide](/grid/library/knowledge/sections/guides/cyber_capabilities_guide.yaml)
  - [Memory Management Guide](/grid/library/knowledge/sections/guides/memory_management_guide.yaml)
  - [Contributing Documentation Guide](/grid/library/knowledge/sections/guides/writing/contributing_documentation_guide.yaml)
metadata:
  category: guides
  tags:
  - python
  - execution
  - programming
  - capabilities
  - api
  - best_practices
  confidence: 0.9
  priority: 1
  source: research_draft
  version: 2
  updated: '2025-08-16T12:26:29.381305Z'
